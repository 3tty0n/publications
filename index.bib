@article{takahashi2021ipsj-pro-paper,
author = {Shusuke Takahashi AND Yusuke Izawa AND Hidehiko Masuhara AND Youyou Cong},
title = {An approach to collect object graphs for data-structure live programming based on a language implementation framework},
note = {Presented at the IPSJ PRO 2021-3-(5) in November 2021. 13 pages. In press},
journal = {Journal of Information Processing},
year = {2022},
month = {1},
abstract = {Data-structure live programming environments execute a program, collect object graphs (objects and their mutual references) created and modified during the execution, and visualize the graphs as a node-link diagram. Existing implementations collect object graphs by instrumenting checkpoints, which traverse reachable objects, into every necessary points in the program. Since the cost of each checkpoint is proportional to the number of existing objects, its overhead can be huge. This paper proposes (1) a method to collect object graphs by recording object creation and modification events into an efficient data structure, and (2) to implement the object graph collection mechanism by extending a language implemented on top of a language implementation framework.  As a result, the overhead of object graph collection is merely proportional to the number of object creation/modification operations in total. We implemented the proposed mechanism for the Kanon data-structure live programming environment by extending GraalJS, which is a JavaScript implementation on the Graal/Truffle language implementation framework. We compared our new implementation against the original Kanon, which is based on checkpointing, and confirmed that our implementation improves program execution (and data collection) speed, and has sufficiently small overheads to reconstruct object graphs.},
annote = {refereed},
}
@article{izawa2021jot,
author = {Yusuke Izawa AND Hidehiko Masuhara AND Carl Friedrich Bolz-Tereick AND Youyou Cong},
title = {Threaded Code Generation with a Meta-Tracing JIT Compiler},
year = {2021},
month = {12},
journal = {The Journal of Object Technology Special Issue for ICOOOLPS 2021},
note = {Presented at the ICOOOLPS 2021 workshop in July 2021. 11 pages. In press},
numpages = 11,
archivePrefix = {arXiv},
eprint = {2106.12496},
abstract = {Language implementation frameworks, e.g., RPython and Truffle/Graal, are practical tools for creating efficient virtual machines, including a well-functioning just-in-time (JIT) compiler. It is demanding to support multitier JIT compilation in such a framework for language developers. This paper presents an idea to generate threaded code by reusing an existing meta-tracing JIT compiler, as well as an interpreter design for it. Our approach does not largely modify RPython itself but constructs an effective interpreter definition to enable threaded code generation in RPython. We expect our system to be extended to support multilevel JIT compilation in the RPython framework. We measured the potential performance of our threaded code generation by simulating its behavior in PyPy. We confirmed that our approach reduced code sizes by 80 \% and compilation times by 60 \% compared to PyPy's JIT compiler on average, and ran about 7 \% faster than the interpreter-only execution.},
annote = {refereed}
}
@inproceedings{izawa2022pepm,
author = {Izawa, Yusuke and Masuhara, Hidehiko and Bolz-Tereick, Carl Friedrich},
title = {Two-level Just-in-Time Compilation with One Interpreter and One Engine},
year = 2022,
address = {Virtual},
howpublished = {},
booktitle = {The ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation},
series = {PEPM 2022},
date = {2022-01-17},
note = {\textbf{Refereed}. Short paper. 7 pages},
archivePrefix = {arXiv},
eprint = {2201.09268},
url = {https://popl22.sigplan.org/details/pepm-2022-papers/3/Two-level-Just-in-Time-Compilation-with-One-Interpreter-and-One-Engine},
abstract = {Modern, powerful virtual machines such as those running Java or JavaScript support multi-tier JIT compilation and optimization features to achieve their high performance. However, implementing and maintaining several compilers/optimizers that interact with each other requires hard-working VM developers. In this paper, we propose a technique to realize two-level JIT compilation in RPython without implementing several interpreters or compilers from scratch. As a preliminary realization, we created adaptive RPython, which performs both baseline JIT compilation based on threaded code and tracing JIT compilation. We also implemented a small programming language with it. Furthermore, we preliminarily evaluated the performance of that small language, and our baseline JIT compilation ran 1.77x faster than the interpreter-only execution. Furthermore, we observed that when we apply an optimal JIT compilation for different target methods, the performance was mostly the same as the one optimizing JIT compilation strategy, saving about 40 \% of the compilation code size.},
annote = {refereed}
}
@inproceedings{10.1145/3426422.3426977,
author = {Izawa, Yusuke and Masuhara, Hidehiko},
title = {Amalgamating Different JIT Compilations in a Meta-Tracing JIT Compiler Framework},
year = {2020},
date = {2020-11-17},
isbn = {9781450381758},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/3426422.3426977},
abstract = {Most virtual machines employ just-in-time (JIT) compilers to achieve high-performance. Trace-based compilation and method-based compilation are two major compilation strategies in JIT compilers. In general, the former excels in compiling programs with more in-depth method calls and more dynamic branches, while the latter is suitable for a wide range of programs. Some previous studies have suggested that each strategy has its advantages and disadvantages, and there is no clear winner.  In this paper, we present a new approach, namely, the meta-hybrid JIT compilation strategy. It combines trace-based and method-based compilations to utilize the advantages of both strategies. Moreover, it is realized as a meta JIT compiler framework; thus, we can generate a VM with a hybrid JIT compiler that can apply different program parts by merely writing an interpreter with our framework.  We chose to extend a meta-tracing JIT compiler and supported the two compilations on it. As a prototype, we implemented a simple meta-tracing JIT compiler framework called BacCaml based on the MinCaml compiler by following RPython’s architecture.  We evaluated its performance by creating a small functional programming language with BacCaml and running microbenchmark programs. Furthermore, we performed a synthetic experiment to confirm that there are programs that run faster by hybrid compilation.},
booktitle = {Proceedings of the 16th ACM SIGPLAN International Symposium on Dynamic Languages},
pages = {1–15},
numpages = {15},
keywords = {JIT compiler, RPython, meta-tracing JIT compiler, language implementation framework},
location = {Virtual, USA},
series = {DLS 2020},
note = {\textbf{Refereed}. 15 pages},
annote = {refereed}
}
@inproceedings{masuhara2020live,
author = {Hidehiko Masuhara AND Shusuke Takahashi AND Yusuke Izawa AND Youyou Cong},
title = {Toward a Multi-Language and Multi-Environment Framework for Live Programming},
year = 2020,
url = {http://liveprog.org/live-2020/Toward-a-Multi-Language-and-Multi-Environment-Framework-for-Live-Programming/},
series = {Live 2020},
address = {Virtual},
booktitle = {Proceedings of the 6th Workshop on Live Programming},
numpages = 5,
pages = {1-5},
note = {\textbf{Refereed}. 5 pages},
abstract = {While applications of live programming are expanding to more practical and professional domains, most live programming environments (LPEs) are still developed for a single target language with an original code editor.  We propose an implementation framework for developing LPEs so that we can minimize efforts on implementing an LPE for a different target language and an existing code editor/IDE.  Our idea is to use a meta-JIT language implementation framework (e.g., Graal/Truffle and RPython) and LSP to separate core live programming implementations from language-specific and editor/IDE specific implementations.  This paper takes the Kanon live programming environment as a concrete example and discusses how we can design the framework to accommodate the features of Kanon.  Although the framework design is still underway, the paper presents a sketch of the framework APIs for separating language-specific functions and clarifies the requirements to LSP.},
annote = {refereed}
}
@inproceedings{10.1145/3328433.3328439,
author = {Izawa, Yusuke and Masuhara, Hidehiko and Aotani, Tomoyuki},
title = {Extending a Meta-Tracing Compiler to Mix Method and Tracing Compilation},
year = {2019},
date= {2019-04-02},
isbn = {9781450362573},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/3328433.3328439},
abstract = {Meta-interpreter-based just-in-time compiler frameworks provide a convenient way for language designers to implement efficient virtual machines. Those frameworks either employ tracing-based or method- (or partial evaluation) based strategies, which have their own pros and cons. This paper proposes an approach to enable both tracing- and method-based compilation so that the runtime can selectively apply an appropriate strategy to different parts of a program. The proposal basically extends a meta-tracing compiler to method-based compilation by roll backing at conditional branches, trace-splitting at loop entries, and not following at function calls. As a proof-of-concept, we implemented a tiny meta-tracing compiler in MinCaml by following the RPython's architecture and extended it to support both tracing- and method-based compilation.},
booktitle = {Proceedings of the Conference Companion of the 3rd International Conference on Art, Science, and Engineering of Programming},
articleno = {5},
numpages = {3},
pages = {1-3},
note = {\textbf{Refereed}. 3 pages},
keywords = {language implementation frameworks, tracing JIT compilation, RPython},
location = {Genova, Italy},
series = {Programming 2019},
annote = {refereed}
}
@inproceedings{10.1145/3328433.3328466,
author = {Izawa, Yusuke},
title = {BacCaml: The Meta-Hybrid Just-in-Time Compiler},
year = {2019},
date= {2019-04-02},
isbn = {9781450362573},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/3328433.3328466},
abstract = {Meta-interpreter-based just-in-time compiler frameworks are useful to conveniently build a language runtime with reasonable execution performance.},
booktitle = {Proceedings of the Conference Companion of the 3rd International Conference on Art, Science, and Engineering of Programming},
articleno = {32},
numpages = {3},
pages = {1-3},
note = {\textbf{Refereed}. \textbf{Awarded [*]}. 3 pages},
location = {Genova, Italy},
series = {Programming 2019},
annote = {refereed}
}
@inproceedings{izawa2019jssst,
organization = {{J}apan Society for Software Science and Technology ({JSSST})},
location = {Shibaura Institute of Technology, Tokyo, Japan},
editor = {Kei Ito},
year = {2019},
date = {2019-08-27},
booktitle = {Proceedings of the 36th JSSST Annual Conference},
author = {Yusuke Izawa AND Hidehiko Masuhara AND Tomoyuki Aotani AND Youyou Cong},
title = {A Stack Hybridization for Meta-hybrid Just-in-time Compilation},
pages = {No.~2-L},
pages = {1--9},
review = {false},
keywords = {PyPy, BacCaml, MinCaml, RPython},
url = {http://jssst.or.jp/files/user/taikai/2019/proceedings.html},
note = {Nonrefereed},
abstract = {Meta-interpreter-based language implementation frameworks, such as RPython and Truffe/Graal, are convenient tool for implementing state-of-the-art virtual machines. Those frameworks are classified into trace-based and method- (or ast-) based strategies. RPython uses a trace-based policy to compile straight execution paths, while Truffe/Graal leverages method invocation to compile entire method bodies. Each approach has its own advantages and disadvantages. The trace-based strategy is good at compiling pro- grams with many branching possibilities and able to reduce the size of compiled code, but it is weak at programs with varying control-flow. The method-based strategy is robust with the latter type of programs but it needs thorough method-inlining management to achieve excellent performance. To take advantage of both strategies, we propose a meta-hybrid compilation technique to integrate trace- and method-based compilations, as well as a proof-of-concept implementation called BacCaml. To achieve this goal, we develop a stack hybridization mechanism which makes it possible to coordinate trace- and method-based meta JIT compilation. In the implementation, we extend RPython's architecture and introduced a special syntax for realizing this system in a single interpreter definition.},
annote = {nonrefereed}
}
@misc{takahashi2021ipsj-pro-2,
LANGID = {japanese},
author = {高橋 修祐 AND 伊澤 侑祐 AND 増原 英彦 AND 叢 悠悠},
yomi = {Shusuke Takahashi AND Yusuke Izawa AND Hidehiko Masuhara AND Youyou Cong},
title = {データ構造ライブプログラミングのための言語実現フレームワークに基づくオブジェクトグラフ収集手法},
howpublished = {情報処理学会第136回プログラミング研究会 PRO 2021-3-(5)},
month = nov,
date = {2021-11-01},
year = 2021,
url = {https://sigpro.ipsj.or.jp/pro2021-3/program/},
annote = {nonrefereed}
}
@misc{izawa2021ipsj-pro20213,
LANGID={japanese},
author={伊澤 侑祐 AND 堀江 倫大 AND 緒方 一則 AND 千葉 立寛},
yomi={Yusuke Izawa AND Mitihiro Horie AND Kazunori Ogata AND Tatsuhiro Chiba},
title={Java静的コンパイラを用いたQuarkusフレームワークの性能評価},
howpublished = {情報処理学会第136回プログラミング研究会 PRO 2021-3-(6)},
month=nov,
year=2021,
date={2021-11-01},
url={https://sigpro.ipsj.or.jp/pro2021-3/program/},
annote = {nonrefereed}
}
@misc{izawa2021icooolps,
author = {Yusuke Izawa AND Hidehiko Masuhara AND Carl Friedrich Bolz-Tereick AND Youyou Cong},
title = {Threaded Code Generation with a Meta-tracing JIT Compiler},
year = {2021},
address = {Virtual},
howpublished = {The 16th Workshop on Implementation, Compilation, Optimization of Object-Oriented Languages, Programs and Systems (ICOOOLPS 2021)},
series = {ICOOOLPS 2021},
date = {2021-07-13},
archivePrefix = {arXiv},
eprint = {2106.12496v4},
note = {\textbf{Refereed}},
url = {https://conf.researchr.org/track/ecoop-issta-2021/ecoop-issta-2021-icooolps},
annote = {refereed}
}
@misc{takahashi2021ipsj-pro,
LANGID = {japanese},
author = {高橋 修祐 AND 伊澤 侑祐 AND 増原 英彦 AND 叢 悠悠},
yomi = {Shusuke Takahashi AND Yusuke Izawa AND Hidehiko Masuhara AND Youyou Cong},
title = {言語実現フレームワークに基づく汎言語的オブジェクトグラフ収集手法},
howpublished = {情報処理学会第135回プログラミング研究会 PRO 2021-2-(7)},
month = jul,
date = {2021-07-21},
year = 2021,
url = {https://sigpro.ipsj.or.jp/pro2021-2/program/},
annote = {nonrefereed}
}
@misc{izawa2021ppl-reproduction,
author = {Yusuke Izawa AND Hidehiko Masuhara},
title = {Amalgamating Different {JIT} Compilations in a Meta-tracing {JIT} Compiler Framework},
howpublished = {The 23nd JSSST Workshop on Programming and Programming Languages},
booktitle = {The 23nd JSSST Workshop on Programming and Programming Languages},
year = 2021,
note = {Reproduction of the DLS'20 talk at JSSST PPL},
url = {https://jssst-ppl.org/workshop/2021/},
annote = {nonrefereed}
}
@misc{izawa2021ppl,
author = {Yusuke Izawa AND Hidehiko Masuhara AND Youyou Cong},
title = {An Interpreter Design for Supporting Different {JIT} Compilations in RPython Framework},
howpublished = {The 23nd JSSST Workshop on Programming and Programming Languages},
url = {https://easychair.org/smart-program/PPL2021/},
note = {Poster Presentation},
year = {2021},
annote = {nonrefereed}
}
@misc{takahashi2021ppl,
author = {Shusuke Takahashi AND Yusuke Izawa AND Hidehiko Masuhara AND Youyou Cong},
title = {汎言語的ライブプログラミング環境のためのデータ構造解析手法},
howpublished = {The 23nd JSSST Workshop on Programming and Programming Languages},
url = {https://easychair.org/smart-program/PPL2021/},
note = {Poster Presentation},
year = {2021},
annote = {nonrefereed}
}
@misc{takahashi2020jssstppl,
author = {Shusuke Takahashi AND Yusuke Izawa AND Hidehiko Masuhara AND Youyou Cong},
title = {ライブプログラミング環境は多言語化/多開発環境化の夢を見るか},
howpublished = {The 37th JSSST Anual Conference. Japan Society for Software Science and Technology},
year = 2020,
note = {Poster Presentation},
url = {https://jssst2020.wordpress.com/program/},
annote = {nonrefereed}
}
@misc{izawa2020ppl,
author = {Yusuke Izawa AND Hidehiko Masuhara},
title = {Making different JIT Compilations Dancing to the Same Tune, Acting in the Meta-level},
howpublished = {The 22nd JSSST Workshop on Programming and Programming Languages},
year = 2020,
note = {Poster Presentation},
url = {https://easychair.org/smart-program/PPL2020/},
annote = {nonrefereed}
}
@misc{izawa2019kumiki,
author = {Yusuke Izawa AND Hidehiko Masuhara AND Tomoyuki Aotani},
title = {Meta-hybrid JIT Compilation Approach for the Path-divergence Problem},
howpublished = {The Kumiki 6.0 Meeting},
year = 2019,
month = dec,
annote = {nonrefereed}
}
@misc{izawa2018ppl,
author = {Yusuke Izawa AND Hidehiko Masuhara AND Tomoyuki Aotani},
title = {メタ混合 {JIT} コンパイラの提案},
howpublished = {The 20nd JSSST Workshop on Programming and Programming Languages},
year = 2018,
note = {Poster Presentation},
url = {https://jssst-ppl.org/workshop/2018/program.html},
annote = {nonrefereed}
}
